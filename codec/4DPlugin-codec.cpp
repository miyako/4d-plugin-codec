/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-codec.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : codec
 #	author : miyako
 #	2020/02/03
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-codec.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
    try
    {
        switch(selector)
        {
                // --- codec
                
            case 1 :
                codec_encode(params);
                break;
            case 2 :
                codec_decode(params);
                break;
                
        }
        
    }
    catch(...)
    {
        
    }
}

#pragma mark -

void codec_encode(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    codec_t codec = (codec_t)Param2.getIntValue();
    
    std::vector<uint8_t>data(Param1.getBytesLength());
    memcpy(&data[0], Param1.getBytesPtr(), data.size());
    
    std::string code;
    
    switch (codec) {
        case base64_rfc4648:
            code = cppcodec::base64_rfc4648::encode(data);
            break;
        case base64_url:
            code = cppcodec::base64_url::encode(data);
            break;
        case base64_url_unpadded:
            code = cppcodec::base64_url_unpadded::encode(data);
            break;
        case base32_rfc4648:
            code = cppcodec::base32_rfc4648::encode(data);
            break;
        case base32_crockford:
            code = cppcodec::base32_crockford::encode(data);
            break;
        case base32_hex:
            code = cppcodec::base32_hex::encode(data);
            break;
        case hex_upper:
            code = cppcodec::hex_upper::encode(data);
            break;
        case hex_lower:
            code = cppcodec::hex_lower::encode(data);
            break;
        default:
            break;
    }
    
    returnValue.setUTF8String((const uint8_t *)code.c_str(), (uint32_t)code.length());
    returnValue.setReturn(pResult);
}

void codec_decode(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_LONGINT Param2;
    C_BLOB returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    codec_t codec = (codec_t)Param2.getIntValue();
    
    std::vector<uint8_t>data;
    
    CUTF8String code;
    Param1.copyUTF8String(&code);
    
    switch (codec) {
        case base64_rfc4648:
            data = cppcodec::base64_rfc4648::decode(code);
            break;
        case base64_url:
            data = cppcodec::base64_url::decode(code);
            break;
        case base64_url_unpadded:
            data = cppcodec::base64_url_unpadded::decode(code);
            break;
        case base32_rfc4648:
            data = cppcodec::base32_rfc4648::decode(code);
            break;
        case base32_crockford:
            data = cppcodec::base32_crockford::decode(code);
            break;
        case base32_hex:
            data = cppcodec::base32_hex::decode(code);
            break;
        case hex_upper:
            data = cppcodec::hex_upper::decode(code);
            break;
        case hex_lower:
            data = cppcodec::hex_lower::decode(code);
            break;
        default:
            break;
    }
    
    returnValue.setBytes((const uint8_t *)&data[0], (uint32_t)data.size());
    returnValue.setReturn(pResult);
}

